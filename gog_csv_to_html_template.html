<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GOG Galaxy Game Library</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
  <link href="gog_csv_to_html_template.css" rel="stylesheet">
  <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18",
            "react-dom/client": "https://esm.sh/react-dom@18/client",
            "react-window": "https://esm.sh/react-window@1.8.8",
            "@xenova/transformers": "https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js",
            "plotly.js-dist": "https://esm.sh/plotly.js-dist@2.27.0",
            "ml-matrix": "https://esm.sh/ml-matrix@6.10.4",
            "ml-kmeans": "https://esm.sh/ml-kmeans@4.0.0"
        }
    }
  </script>
  <svg style="display: none;">
    <symbol id="gog" viewBox="0 0 24 24">
      <path fill="#000000" d="M4,3H20A2,2 0 0,1 22,5V19A2,2 0 0,1 20,21H4A2,2 0 0,1 2,19V5A2,2 0 0,1 4,3M10.46,5.54C9.95,5.54 9.54,5.95 9.54,6.46V9.54A0.92,0.92 0 0,0 10.46,10.46H13.54A0.92,0.92 0 0,0 14.46,9.54V6.46C14.46,5.95 14.05,5.54 13.54,5.54H10.46M11.08,6.77H12.92A0.31,0.31 0 0,1 13.23,7.08V8.92A0.31,0.31 0 0,1 12.92,9.23H11.08A0.31,0.31 0 0,1 10.77,8.92V7.08A0.31,0.31 0 0,1 11.08,6.77M4.92,5.54A0.92,0.92 0 0,0 4,6.46V9.54C4,10.05 4.41,10.46 4.92,10.46H7.08V9.23H5.54C5.37,9.23 5.23,9.09 5.23,8.92V7.08C5.23,6.91 5.37,6.77 5.54,6.77H7.38A0.31,0.31 0 0,1 7.69,7.08V10.77A0.31,0.31 0 0,1 7.38,11.08H4V12.31H8C8.5,12.31 8.92,11.89 8.92,11.38V6.46A0.92,0.92 0 0,0 8,5.54H4.92M16,5.54C15.5,5.54 15.08,5.95 15.08,6.46V9.54C15.08,10.05 15.5,10.46 16,10.46H18.15V9.23H16.62C16.45,9.23 16.31,9.09 16.31,8.92V7.08C16.31,6.91 16.45,6.77 16.62,6.77H18.46C18.63,6.77 18.77,6.91 18.77,7.08V10.77C18.77,10.94 18.63,11.08 18.46,11.08H15.08V12.31H19.08C19.59,12.31 20,11.89 20,11.38V6.46C20,5.95 19.59,5.54 19.08,5.54H16M9.85,13.54C9.34,13.54 8.92,13.95 8.92,14.46V17.54C8.92,18.05 9.34,18.46 9.85,18.46H12.92C13.43,18.46 13.85,18.05 13.85,17.54V14.46C13.85,13.95 13.43,13.54 12.92,13.54H9.85M10.46,14.77H12.31C12.5,14.77 12.62,14.91 12.62,15.08V16.92A0.31,0.31 0 0,1 12.31,17.23H10.46C10.29,17.23 10.15,17.09 10.15,16.92V15.08A0.31,0.31 0 0,1 10.46,14.77M4.92,13.54C4.41,13.54 4,13.95 4,14.46V17.54C4,18.05 4.41,18.46 4.92,18.46H8.31V17.23H5.54C5.37,17.23 5.23,17.09 5.23,16.92V15.08C5.23,14.91 5.37,14.77 5.54,14.77H8.31V13.54H4.92M15.38,13.54C14.87,13.54 14.46,13.95 14.46,14.46V18.46H15.69V15.08A0.31,0.31 0 0,1 16,14.77H16.62V18.46H17.85V14.77H18.77V18.46H20V13.54H15.38Z"/>
    </symbol>
    <symbol id="steam" viewBox="0 0 24 24">
      <path fill="#1a1918" d="M11.97985 0.25C5.86315 0.25 0.85233 5.009475 0.376465 11.057475L6.61715 13.661325c0.52865 -0.365275 1.1679 -0.578075 1.854875 -0.578075 0.062 0 0.12315 0.0017 0.183475 0.00505l2.7756 -4.05995v-0.05695c0 -2.443 1.96965 -4.431075 4.39085 -4.431075 2.421225 0 4.39085 1.988075 4.39085 4.431075 0 2.442975 -1.969625 4.4319 -4.39085 4.4319 -0.0335 0 -0.066175 -0.00085 -0.0997 -0.001675L11.7637 16.25095c0.002525 0.052775 0.0042 0.10555 0.0042 0.1575 0 1.83475 -1.4787 3.32685 -3.295875 3.32685 -1.59515 0 -2.92975 -1.149425 -3.23135 -2.67085L0.7769275 15.202025C2.15928 20.1341 6.649825 23.75 11.97985 23.75c6.430875 0 11.6436 -5.261325 11.6436 -11.75 0 -6.489525 -5.212725 -11.75 -11.6436 -11.75Zm-4.30675 17.828675 -1.4301 -0.596525c0.253025 0.53285 0.692025 0.97855 1.274275 1.223175 1.258375 0.5295 2.709425 -0.072875 3.233875 -1.3438 0.25385 -0.61495 0.255525 -1.29355 0.0042 -1.910175 -0.25135 -0.6166 -0.726375 -1.0975 -1.33545 -1.35385 -0.605725 -0.25385 -1.254175 -0.24465 -1.823875 -0.02765l1.477875 0.6166c0.928275 0.390425 1.367275 1.46615 0.9802 2.402775 -0.386225 0.93665 -1.452725 1.37985 -2.381 0.98945Zm11.07475 -9.1072c0 -1.627825 -1.312825 -2.9532 -2.92555 -2.9532 -1.6136 0 -2.9264 1.325375 -2.9264 2.9532 0 1.627825 1.3128 2.952375 2.9264 2.952375 1.612725 0 2.92555 -1.32455 2.92555 -2.952375Zm-5.1189 -0.005025c0 -1.22485 0.9844 -2.217625 2.197525 -2.217625 1.21395 0 2.198375 0.992775 2.198375 2.217625s-0.984425 2.217625 -2.198375 2.217625c-1.213125 0 -2.197525 -0.992775 -2.197525 -2.217625Z" stroke-width="0.25"></path>
    </symbol>
    <symbol id="epic" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M4 1a1.5 1.5 0 0 0 -1.5 1.5v16a0.5 0.5 0 0 0 0.297 0.457l9 4a0.5 0.5 0 0 0 0.406 0l9 -4a0.5 0.5 0 0 0 0.297 -0.457v-16A1.5 1.5 0 0 0 20 1H4Zm10.25 11.75h-1.5v-8.5h1.5v8.5ZM8 18.5l4 2 4 -2H8ZM8 4.25H5.25v8.5H8v-1.5H6.75v-2H8v-1.5H6.75v-2H8v-1.5Zm2.5 0H8.75v8.5h1.5v-2.5h0.25a1.75 1.75 0 0 0 1.75 -1.75V6a1.75 1.75 0 0 0 -1.75 -1.75Zm0 4.5h-0.25v-3h0.25a0.25 0.25 0 0 1 0.25 0.25v2.5a0.25 0.25 0 0 1 -0.25 0.25Zm4.25 -3.25c0 -0.69 0.56 -1.25 1.25 -1.25h1.5c0.69 0 1.25 0.56 1.25 1.25v2h-1.5V5.75h-1v5.5h1V9.5h1.5v2c0 0.69 -0.56 1.25 -1.25 1.25H16c-0.69 0 -1.25 -0.56 -1.25 -1.25v-6ZM5.5 16.25h12v-1.5h-12v1.5Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
    <symbol id="xboxone" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5Zm7 3a7.968 7.968 0 0 0 -3.526 0.817A12.85 12.85 0 0 1 12 6.427a12.848 12.848 0 0 1 3.526 -1.61A7.968 7.968 0 0 0 12 4Zm-8 8c0 1.684 0.52 3.246 1.408 4.535 0.882 -3.511 2.448 -6.393 4.573 -8.478 -1.206 -0.93 -2.383 -1.62 -3.392 -1.95A7.979 7.979 0 0 0 4 12Zm13.451 5.855A7.971 7.971 0 0 1 12 20a7.972 7.972 0 0 1 -5.451 -2.145c0.872 -2.72 3.063 -5.724 5.451 -8.041 2.389 2.317 4.579 5.321 5.451 8.041ZM20 12c0 1.683 -0.52 3.245 -1.408 4.534 -0.882 -3.51 -2.448 -6.392 -4.573 -8.477 1.206 -0.93 2.383 -1.62 3.392 -1.95A7.979 7.979 0 0 1 20 12Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
    <symbol id="xbox" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5Zm7 3a7.968 7.968 0 0 0 -3.526 0.817A12.85 12.85 0 0 1 12 6.427a12.848 12.848 0 0 1 3.526 -1.61A7.968 7.968 0 0 0 12 4Zm-8 8c0 1.684 0.52 3.246 1.408 4.535 0.882 -3.511 2.448 -6.393 4.573 -8.478 -1.206 -0.93 -2.383 -1.62 -3.392 -1.95A7.979 7.979 0 0 0 4 12Zm13.451 5.855A7.971 7.971 0 0 1 12 20a7.972 7.972 0 0 1 -5.451 -2.145c0.872 -2.72 3.063 -5.724 5.451 -8.041 2.389 2.317 4.579 5.321 5.451 8.041ZM20 12c0 1.683 -0.52 3.245 -1.408 4.534 -0.882 -3.51 -2.448 -6.392 -4.573 -8.477 1.206 -0.93 2.383 -1.62 3.392 -1.95A7.979 7.979 0 0 1 20 12Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
    <symbol id="amazon" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5Zm11.301 13.074 -1.167 1.08a0.368 0.368 0 0 1 -0.505 -0.006l-0.778 -0.752a0.403 0.403 0 0 0 -0.532 -0.01c-0.53 0.432 -1.486 1.003 -2.522 1.003 -1.561 0 -2.836 -0.874 -2.836 -2.621 0 -1.748 1.088 -3.58 5.3 -3.58V8.17a1.158 1.158 0 0 0 -1.204 -0.988c-0.853 0 -1.299 0.568 -1.49 1.018 -0.073 0.173 -0.242 0.301 -0.429 0.284l-1.537 -0.139c-0.198 -0.017 -0.347 -0.188 -0.307 -0.382 0.214 -1.026 1.16 -2.571 3.763 -2.571 2.922 0 3.643 1.508 3.638 2.263v4.507c0 0.34 0.145 0.808 0.627 1.37 0.136 0.16 0.133 0.4 -0.02 0.542Zm-3.036 -3.538s0.216 2.003 -0.727 2.721c-0.514 0.392 -1.157 0.337 -1.538 0 -0.459 -0.405 -0.581 -1.193 -0.203 -1.774 0.693 -1.065 2.467 -0.947 2.467 -0.947Zm4.713 5.16c0.504 -0.043 1.028 -0.087 1.142 0.042 0.208 0.235 -0.05 0.945 -0.252 1.497 -0.135 0.37 -0.244 0.669 -0.17 0.708 0.367 0.2 1.702 -2.275 1.184 -2.695 -0.594 -0.482 -2.999 0.134 -2.922 0.4 0.038 0.132 0.518 0.09 1.018 0.048Zm-13.033 -0.005c1.232 0.595 3.619 1.749 6.95 1.749 2.712 0 4.5 -0.604 5.56 -0.962 0.59 -0.199 0.955 -0.322 1.129 -0.223 0.487 0.276 -2.842 2.354 -6.69 2.354 -4.4 0 -8.2 -3.004 -7.875 -3.248 0.096 -0.071 0.41 0.08 0.926 0.33Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
    <symbol id="ubisoft" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5ZM4 12a8 8 0 0 0 7.982 8L12 20a8 8 0 1 0 -8 -8Zm1.453 -2.288c0.342 -0.427 0.736 -0.82 1.165 -1.163 1.478 -1.183 3.482 -1.86 5.464 -1.25 1.149 0.353 1.978 0.93 2.547 1.637 0.568 0.705 0.855 1.512 0.97 2.295 0.21 1.437 -0.153 2.86 -0.53 3.605a3.378 3.378 0 1 1 -5.421 -3.838c-1.065 0.33 -1.848 1.058 -2.032 2.079 -0.34 1.885 0.454 3.335 1.522 4.342a6.7 6.7 0 0 0 1.67 1.147c0.532 0.255 0.953 0.36 1.169 0.367l0.023 0a6.933 6.933 0 1 0 -6.547 -9.221Zm9.05 1.442a3.393 3.393 0 0 0 -0.65 -0.557c-1.29 -0.863 -2.95 -1.051 -4.354 -0.667 -1.407 0.386 -2.649 1.38 -2.933 2.957 -0.342 1.898 0.26 3.437 1.171 4.581a6.93 6.93 0 0 1 -2.576 -4.32c0.02 -1.287 0.843 -2.742 2.123 -3.766 1.287 -1.03 2.932 -1.541 4.485 -1.064 0.967 0.297 1.607 0.762 2.03 1.287 0.372 0.464 0.593 0.997 0.704 1.55Zm-0.398 3.224a2.311 2.311 0 1 0 -0.034 0.072l-0.004 -0.003 0.038 -0.07Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
    <symbol id="origin" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5Zm0.818 10.09 -1.09 1.455h1.5L4 15.818h8.364l2.909 -4.727 1.09 1.818h-1.09l-0.897 1.454h2.715l1.09 1.455H20l-4.727 -7.636 -4 6.181H6.909l1.321 -1.818h2.68L12 11.091H5.818Zm1.818 -2.908 -1.09 1.454h6.181l1.091 -1.454H7.636Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
    <symbol id="battlenet" viewBox="0 0 32 32">
      <path fill="#000000" stroke-width="0" stroke-linecap="round" stroke-linejoin="round" d="M 26.578125 14.339844 C 26.578125 14.339844 28.882813 14.457031 28.882813 13.101563 C 28.882813 11.332031 25.8125 9.738281 25.8125 9.738281 C 25.8125 9.738281 26.292969 8.71875 26.59375 8.148438 C 26.894531 7.578125 27.738281 5.359375 27.8125 4.851563 C 27.90625 4.210938 27.761719 4.011719 27.761719 4.011719 C 27.554688 5.378906 25.328125 9.316406 25.148438 9.449219 C 22.976563 8.433594 19.992188 8.148438 19.992188 8.148438 C 19.992188 8.148438 17.070313 2 14.320313 2 C 11.59375 2 11.609375 7.265625 11.609375 7.265625 C 11.609375 7.265625 10.839844 5.773438 9.871094 5.773438 C 8.457031 5.773438 7.992188 7.90625 7.992188 10.222656 C 5.203125 10.222656 2.855469 10.847656 2.644531 10.90625 C 2.4375 10.964844 1.777344 11.445313 2.074219 11.386719 C 2.6875 11.191406 5.554688 10.746094 8.0625 10.964844 C 8.203125 13.164063 9.488281 16.03125 9.488281 16.03125 C 9.488281 16.03125 6.730469 20.023438 6.730469 22.871094 C 6.730469 23.621094 7.058594 24.992188 9.035156 24.992188 C 10.695313 24.992188 12.558594 23.996094 12.90625 23.796875 C 12.601563 24.230469 12.375 25.0625 12.375 25.445313 C 12.375 25.757813 12.5625 26.644531 13.839844 26.644531 C 15.480469 26.644531 17.316406 25.386719 17.316406 25.386719 C 17.316406 25.386719 19.050781 28.261719 20.53125 29.578125 C 20.929688 29.933594 21.3125 30 21.3125 30 C 21.3125 30 19.839844 28.585938 17.902344 24.9375 C 19.703125 23.828125 21.578125 21.203125 21.578125 21.203125 C 21.578125 21.203125 21.800781 21.210938 23.511719 21.210938 C 26.191406 21.210938 29.996094 20.648438 29.996094 18.519531 C 30 16.324219 26.578125 14.339844 26.578125 14.339844 Z M 26.875 13.015625 C 26.875 13.792969 26.136719 13.785156 26.136719 13.785156 L 25.574219 13.820313 C 25.574219 13.820313 24.507813 13.261719 23.859375 12.996094 C 23.859375 12.996094 24.863281 11.453125 25.097656 11.023438 C 25.273438 11.128906 26.875 12.128906 26.875 13.015625 Z M 15.660156 5.097656 C 16.921875 5.097656 18.71875 8.066406 18.71875 8.066406 C 18.71875 8.066406 15.914063 7.816406 13.605469 9.171875 C 13.667969 7.035156 14.386719 5.097656 15.660156 5.097656 Z M 10.671875 7.503906 C 11.070313 7.503906 11.460938 7.992188 11.625 8.402344 C 11.625 8.675781 11.765625 10.269531 11.765625 10.269531 L 9.453125 10.179688 C 9.453125 8.097656 10.269531 7.503906 10.671875 7.503906 Z M 10.429688 21.976563 C 9.164063 21.976563 8.90625 21.273438 8.90625 20.640625 C 8.90625 19.207031 10.050781 17.199219 10.050781 17.199219 C 10.050781 17.199219 11.335938 19.898438 13.574219 21.035156 C 12.464844 21.6875 11.546875 21.976563 10.429688 21.976563 Z M 14.535156 24.800781 C 13.648438 24.800781 13.539063 24.226563 13.539063 24.09375 C 13.539063 23.683594 13.863281 23.195313 13.863281 23.195313 C 13.863281 23.195313 15.351563 22.191406 15.445313 22.082031 L 16.546875 24.136719 C 16.546875 24.136719 15.421875 24.800781 14.535156 24.800781 Z M 17.300781 23.683594 C 16.761719 22.742188 16.363281 21.757813 16.363281 21.757813 C 16.363281 21.757813 18.578125 21.898438 19.769531 20.671875 C 19.027344 21.003906 17.84375 21.425781 16.46875 21.296875 C 19.34375 18.765625 21.023438 16.929688 22.441406 15.035156 C 22.320313 14.886719 21.671875 14.433594 21.511719 14.359375 C 20.65625 15.390625 17.324219 18.949219 14.238281 20.710938 C 10.332031 18.582031 9.511719 12.320313 9.429688 11.019531 L 11.5625 11.222656 C 11.5625 11.222656 10.761719 12.644531 10.761719 13.691406 C 10.761719 14.734375 10.886719 14.789063 10.886719 14.789063 C 10.886719 14.789063 10.859375 12.96875 11.984375 11.5625 C 12.84375 16.125 13.738281 18.460938 14.433594 19.855469 C 14.789063 19.707031 15.449219 19.414063 15.449219 19.414063 C 15.449219 19.414063 13.480469 13.738281 13.589844 9.898438 C 14.484375 9.421875 15.808594 8.929688 17.300781 8.929688 C 21.230469 8.929688 24.390625 10.617188 24.390625 10.617188 L 23.15625 12.34375 C 23.15625 12.34375 22.054688 10.351563 20.496094 9.996094 C 21.316406 10.605469 22.238281 11.414063 22.714844 12.574219 C 19.457031 11.304688 15.527344 10.632813 14.265625 10.484375 C 14.15625 10.949219 14.171875 11.613281 14.171875 11.613281 C 14.171875 11.613281 19.441406 12.585938 23.277344 14.777344 C 23.25 19.574219 18.023438 23.257813 17.300781 23.683594 Z M 22.292969 20.097656 C 22.292969 20.097656 23.929688 17.953125 23.902344 15.109375 C 23.902344 15.109375 26.546875 16.746094 26.546875 18.34375 C 26.546875 20.125 22.292969 20.097656 22.292969 20.097656 Z"></path>
    </symbol>
    <symbol id="playstation" viewBox="0 0 24 24">
      <path fill="#000000" fill-rule="evenodd" d="M5 1a4 4 0 0 0 -4 4v14a4 4 0 0 0 4 4h14a4 4 0 0 0 4 -4V5a4 4 0 0 0 -4 -4H5Zm4.976 16.322 2.618 0.879V8.69c0 -0.33 0.223 -0.728 0.489 -0.728 0.338 0 0.552 0.46 0.552 0.729v3.585c0.216 0.126 0.723 0.378 1.02 0.378l0.023 0c0.404 0.001 1.814 0.005 1.814 -2.145 0 -2.192 -1.157 -3.02 -2.122 -3.335L9.976 5.8v11.522Zm-0.727 -0.657v-1.263c-0.61 0.227 -1.169 0.41 -1.513 0.464 -0.647 0.1 -1.35 0.027 -1.262 -0.341 0.075 -0.315 1.68 -0.874 2.775 -1.221v-1.437C7.173 13.515 4 14.611 4 15.342c0 1.034 2.428 1.344 2.997 1.378 0.332 0.02 1.254 0.053 2.252 -0.055ZM20 14.895c0 0.697 -4.259 2.287 -6.678 3.094v-1.504a220.385 220.385 0 0 0 3.526 -1.314c0.861 -0.345 1.016 -0.569 0.603 -0.758 -0.267 -0.123 -0.844 -0.152 -1.343 0a65.85 65.85 0 0 0 -2.786 0.954V13.93c0.918 -0.25 1.895 -0.45 2.682 -0.482 1.54 -0.06 3.996 0.534 3.996 1.447Z" clip-rule="evenodd" stroke-width="1"></path>
    </symbol>
  </svg>
</head>

<body>
  <div id="root"></div>

  <script type="module">
    import React from 'react';
    import { createRoot } from 'react-dom/client';
    import { FixedSizeList as List } from 'react-window';
    import { pipeline, env } from '@xenova/transformers';
    import Plotly from 'plotly.js-dist';
    import { Matrix } from 'ml-matrix';
    import KMeans from 'ml-kmeans';

    // Configure transformers to use CDN models
    env.allowRemoteModels = true;
    env.allowLocalModels = false;

    const { useState, useEffect, useMemo, memo, useRef } = React;

    // Embedded games data
    const GAMES_DATA = [[embedded_json]];

    if (GAMES_DATA.length === 0) {
      document.getElementById('root').innerHTML = '<div style="text-align: center; padding: 50px; color: red;">No games data available</div>';
      throw new Error('No games data available');
    }

    console.log(`Loaded ${GAMES_DATA.length} games successfully`);

    function PlatformIcon({ platform, className = '', title = '' }) {
      return React.createElement('svg', {
        className: `${className}`,
        title: title || platform
      }, [
        React.createElement('use', { href: `#${platform.toLowerCase()}` })
      ]);
    }

    // Axis configuration with short labels for compact display
    const AXIS_CONFIG = [
      { key: 'core_mechanics_complexity', label: 'Mech Cmplx', shortLabel: 'MC' },
      { key: 'core_mechanics_count', label: 'Mech Count', shortLabel: 'Ct' },
      { key: 'player_agency', label: 'Agency', shortLabel: 'Ag' },
      { key: 'player_impact', label: 'Impact', shortLabel: 'Im' },
      { key: 'narrative_density', label: 'Story', shortLabel: 'St' },
      { key: 'narrative_integration', label: 'Story Int', shortLabel: 'SI' },
      { key: 'scope_scale', label: 'Scope', shortLabel: 'Sc' },
      { key: 'pacing_controlled', label: 'Pace Ctrl', shortLabel: 'PC' },
      { key: 'pacing_compelled', label: 'Pace Push', shortLabel: 'PP' },
      { key: 'replayability', label: 'Replay', shortLabel: 'Re' },
      { key: 'player_driven_world_change', label: 'World Chg', shortLabel: 'WC' },
      { key: 'multiplayer_integration', label: 'Multi', shortLabel: 'Mp' },
      { key: 'technical_execution', label: 'Tech', shortLabel: 'Te' },
      { key: 'aesthetics_core', label: 'Visual', shortLabel: 'Vi' }
    ];

    // Game recommendation system using axis data
    function extractAxisVector(game) {
      if (!game.axis_info) return null;
      return AXIS_CONFIG.map(axis => game.axis_info[axis.key] || 0);
    }

    // MiniLM embedding pipeline - will be initialized async
    let embeddingPipeline = null;
    const embeddingQueue = new Map();
    let isInitializing = false;

    // Initialize the embedding pipeline
    async function initializeEmbeddings() {
      if (isInitializing || embeddingPipeline) return embeddingPipeline;

      isInitializing = true;
      try {
        console.log('Initializing MiniLM embedding pipeline...');
        embeddingPipeline = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
        console.log('MiniLM embedding pipeline initialized successfully');

        // Process any queued embedding requests
        for (const [text, resolver] of embeddingQueue) {
          try {
            const result = await embeddingPipeline(text, { pooling: 'mean', normalize: true });
            resolver.resolve(Array.from(result.data));
          } catch (error) {
            console.warn('Error processing queued embedding:', error);
            resolver.reject(error);
          }
        }
        embeddingQueue.clear();

        return embeddingPipeline;
      } catch (error) {
        console.error('Failed to initialize embedding pipeline:', error);
        isInitializing = false;
        throw error;
      }
    }

    // Get MiniLM embedding for text
    async function createMiniLMEmbedding(text) {
      const normalizedText = text.toLowerCase().trim();

      if (!normalizedText) {
        return new Array(384).fill(0); // MiniLM-L6-v2 produces 384-dimensional vectors
      }

      try {
        if (!embeddingPipeline) {
          if (!isInitializing) {
            // Start initialization if not already started
            initializeEmbeddings().catch(console.error);
          }

          // Queue the request and return a promise
          return new Promise((resolve, reject) => {
            embeddingQueue.set(normalizedText, { resolve, reject });
          });
        }

        const result = await embeddingPipeline(normalizedText, { pooling: 'mean', normalize: true });
        return Array.from(result.data);
      } catch (error) {
        console.warn('Error creating MiniLM embedding, falling back to simple hash:', error);

        // Fallback to a simple hash-based embedding if MiniLM fails
        const embedding = new Array(384).fill(0);
        for (let i = 0; i < 384; i++) {
          let hashValue = 0;
          for (let j = 0; j < normalizedText.length; j++) {
            hashValue += normalizedText.charCodeAt(j) * (i + 1);
          }
          embedding[i] = Math.tanh(Math.sin(hashValue / 10000));
        }

        // Normalize the fallback embedding
        const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
        if (magnitude > 0) {
          for (let i = 0; i < 384; i++) {
            embedding[i] = embedding[i] / magnitude;
          }
        }

        return embedding;
      }
    }

    // Cache for computed embeddings
    const embeddingCache = new Map();

    async function getTextEmbedding(text) {
      if (embeddingCache.has(text)) {
        return embeddingCache.get(text);
      }

      try {
        const embedding = await createMiniLMEmbedding(text);
        embeddingCache.set(text, embedding);
        return embedding;
      } catch (error) {
        console.warn('Error getting text embedding:', error);
        // Return zero vector as fallback
        const fallback = new Array(384).fill(0);
        embeddingCache.set(text, fallback);
        return fallback;
      }
    }

    // Create comprehensive game vector with better normalization
    async function extractComprehensiveGameVector(game) {
      const axisVector = extractAxisVector(game);
      if (!axisVector) return null;

      try {
        // Get individual embeddings for each genre/tag and average them
        const allTerms = [...(game.genres || []), ...(game.tags || [])];

        let semanticEmbedding;
        if (allTerms.length === 0) {
          semanticEmbedding = new Array(384).fill(0);
        } else {
          // Get embeddings for each term individually
          const termEmbeddings = await Promise.all(
            allTerms.map(term => getTextEmbedding(term.trim()))
          );

          // Average the embeddings (this handles varying numbers of terms better)
          semanticEmbedding = new Array(384).fill(0);
          for (const embedding of termEmbeddings) {
            for (let i = 0; i < 384; i++) {
              semanticEmbedding[i] += embedding[i];
            }
          }

          // Normalize by number of terms
          for (let i = 0; i < 384; i++) {
            semanticEmbedding[i] = semanticEmbedding[i] / termEmbeddings.length;
          }
        }

        // Improved scaling: Keep axis values in 0-1 range but apply variance normalization
        // This preserves the meaning of the axis values while making them comparable to embeddings
        const axisVariance = axisVector.reduce((sum, val) => sum + (val - 0.5) ** 2, 0) / axisVector.length;
        const axisScale = Math.max(0.1, Math.sqrt(axisVariance)); // Prevent division by very small numbers
        const normalizedAxisVector = axisVector.map(val => val / axisScale);

        // Semantic embeddings are already normalized, but ensure they have proper magnitude
        const semanticMagnitude = Math.sqrt(semanticEmbedding.reduce((sum, val) => sum + val * val, 0));
        const normalizedSemanticVector = semanticMagnitude > 0
          ? semanticEmbedding.map(val => val / semanticMagnitude)
          : semanticEmbedding;

        // Balanced weighting - axis data is more structured but semantic adds context
        const axisWeight = 1.2;  // Slightly higher weight for structured data
        const semanticWeight = 2.0;

        const weightedAxisVector = normalizedAxisVector.map(val => val * axisWeight);
        const weightedSemanticVector = normalizedSemanticVector.map(val => val * semanticWeight);

        // Combine weighted vectors
        const combinedVector = [...weightedAxisVector, ...weightedSemanticVector];

        // Final L2 normalization for cosine similarity calculations
        const magnitude = Math.sqrt(combinedVector.reduce((sum, val) => sum + val * val, 0));
        if (magnitude > 0) {
          return combinedVector.map(val => val / magnitude);
        }

        return combinedVector;
      } catch (error) {
        console.warn('Error extracting comprehensive game vector:', error);
        // Better fallback: normalize axis vector properly
        const normalizedAxisFallback = axisVector.map(val => val / Math.sqrt(axisVector.length));
        return [...normalizedAxisFallback, ...new Array(384).fill(0)];
      }
    }

    function euclideanDistance(a, b) {
      if (!a || !b || a.length !== b.length) return Infinity;
      return Math.sqrt(a.reduce((sum, val, i) => sum + (val - b[i]) ** 2, 0));
    }

    function cosineSimilarity(a, b) {
      if (!a || !b || a.length !== b.length) return 0;

      let dotProduct = 0;
      let magnitudeA = 0;
      let magnitudeB = 0;

      for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        magnitudeA += a[i] * a[i];
        magnitudeB += b[i] * b[i];
      }

      magnitudeA = Math.sqrt(magnitudeA);
      magnitudeB = Math.sqrt(magnitudeB);

      if (magnitudeA === 0 || magnitudeB === 0) return 0;

      return dotProduct / (magnitudeA * magnitudeB);
    }

    async function findSimilarGames(selectedGame, allGames, k = 5) {
      try {
        const selectedVector = await extractComprehensiveGameVector(selectedGame);
        if (!selectedVector) return [];

        const candidates = [];

        // Process games in batches to avoid blocking the UI
        const batchSize = 10;
        for (let i = 0; i < allGames.length; i += batchSize) {
          const batch = allGames.slice(i, i + batchSize);

          for (const game of batch) {
            if (game.id === selectedGame.id) continue;

            try {
              const gameVector = await extractComprehensiveGameVector(game);
              if (!gameVector) continue;

              // Calculate cosine similarity (ranges from -1 to 1, where 1 = identical)
              const similarity = cosineSimilarity(selectedVector, gameVector);

              candidates.push({
                game,
                vector: gameVector,
                similarity: similarity
              });
            } catch (error) {
              console.warn(`Error processing game ${game.title}:`, error);
            }
          }

          // Yield control to prevent UI blocking
          await new Promise(resolve => setTimeout(resolve, 0));
        }

        return candidates
          .sort((a, b) => b.similarity - a.similarity) // Sort by similarity descending (highest similarity first)
          .slice(0, k);
      } catch (error) {
        console.error('Error finding similar games:', error);
        return [];
      }
    }

    function AxisVisualization({ axisInfo }) {
      if (!axisInfo) {
        return React.createElement('div', {
          className: 'axis-visualization',
          style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            color: '#6c757d',
            fontSize: '0.6rem',
            fontStyle: 'italic'
          }
        }, 'No axis data');
      }

      return React.createElement('div', { className: 'axis-visualization' },
        React.createElement('div', { className: 'axis-grid' },
          AXIS_CONFIG.map((axis, index) => {
            const value = axisInfo[axis.key] || 0;
            const percentage = Math.round(value * 100);

            return React.createElement('div', {
              className: 'axis-item',
              key: axis.key,
              title: `${axis.label}: ${(value * 100).toFixed(0)}%`
            }, [
              React.createElement('div', {
                className: 'axis-label',
                key: 'label'
              }, axis.shortLabel),
              React.createElement('div', {
                className: 'axis-bar',
                key: 'bar'
              },
                React.createElement('div', {
                  className: 'axis-fill',
                  style: { width: `${percentage}%` }
                })
              ),
              React.createElement('div', {
                className: 'axis-value',
                key: 'value'
              }, percentage)
            ]);
          })
        )
      );
    }

    function GameCard({ game, isSelected, onClick }) {
      const cardStyle = game.square_icon ? {
        '--bg-image': `url(${game.square_icon})`
      } : {};

      // Extract year from release date
      const releaseYear = game.release_date && game.release_date !== 'Unknown'
        ? game.release_date.split(',').pop()?.trim() || ''
        : '';

      // Get first 2 genres for preview
      const genrePreview = game.genres.join(', ');

      // Developer preview (first developer only)
      const developerPreview = game.developers.length > 0 ? game.developers[0] : '';

      return React.createElement('div', {
        className: 'game-card' + (isSelected ? ' selected' : ''),
        onClick: () => onClick(game),
        style: cardStyle
      }, [
        React.createElement('div', { className: 'game-meta-compact', key: 'meta' }, [
          React.createElement('div', { className: 'game-meta-left', key: 'left' }, [
            React.createElement('div', { className: 'game-card-header', key: 'header' }, [
              React.createElement('div', { className: 'game-title', key: 'title' }, [
                game.title,
                React.createElement('div', { className: 'platform-icons-container', key: 'icons' },
                  game.platforms.map(platform =>
                    React.createElement(PlatformIcon, {
                      key: platform,
                      platform: platform,
                      className: 'card-platform-icon',
                      title: platform.toUpperCase()
                    })
                  )
                )
              ]),
              React.createElement('div', { className: 'game-subtitle', key: 'subtitle' }, [
                React.createElement('span', { key: 'dev' }, developerPreview ? developerPreview : 'Unknown Developer'),
                React.createElement('span', { className: 'release-year', key: 'year' }, releaseYear ? releaseYear : 'Unknown Year')
              ].filter(Boolean))
            ]),
            React.createElement('span', { className: 'playtime-badge', key: 'playtime' }, game.playtime_display),
            React.createElement('span', { className: 'genre-preview', key: 'genres' }, genrePreview)
          ].filter(Boolean)),
          React.createElement('div', { className: 'game-meta-right', key: 'right' }, [
            game.rating_stars ? React.createElement('span', { className: 'rating-stars', key: 'rating', style: { fontSize: '0.7rem' } }, game.rating_stars) : null,
            game.my_rating && parseFloat(game.my_rating) > 0 ? React.createElement('span', { className: 'rating-badge', key: 'rating-num' }, game.my_rating) : null,
            // Axis Visualization Section
            React.createElement(AxisVisualization, {
              key: 'axis-viz',
              axisInfo: game.axis_info
            }),
          ].filter(Boolean))
        ])
      ]);
    }

    function CarouselSlide({ index, style, data }) {
      const { images, gameTitle, onImageClick } = data;
      const image = images[index];

      return React.createElement('div', {
        style: style,
        className: 'carousel-slide'
      },
        React.createElement('img', {
          src: image,
          alt: `${gameTitle} Screenshot ${index + 1}`,
          className: 'carousel-image',
          loading: 'lazy',
          onClick: () => onImageClick(image),
          onError: (e) => { e.target.style.display = 'none'; }
        })
      );
    }

    const MemoizedCarouselSlide = memo(CarouselSlide);

    function ImageCarousel({ images, gameTitle, gameId }) {
      const [currentIndex, setCurrentIndex] = useState(0);
      const listRef = useRef(null);
      const containerRef = useRef(null);
      const [containerWidth, setContainerWidth] = useState(400);
      const [containerHeight, setContainerHeight] = useState(64);
      const [modalImage, setModalImage] = useState(null);

      // Calculate container dimensions dynamically
      useEffect(() => {
        const updateDimensions = () => {
          if (containerRef.current) {
            const width = containerRef.current.offsetWidth;
            const height = containerRef.current.offsetHeight;
            setContainerWidth(width);
            setContainerHeight(height);
          }
        };

        updateDimensions();
        window.addEventListener('resize', updateDimensions);
        return () => window.removeEventListener('resize', updateDimensions);
      }, []);

      // Calculate slide width based on container and aspect ratio
      const minSlideWidth = 256; // 16rem in px (16 * 16)
      const defaultSlideWidth = 288; // 18rem in px (18 * 16)
      const maxSlideWidth = 320; // 20rem in px (20 * 16)
      const margin = 10; // 5px padding on each side
      const buttonSpace = 80; // Space for navigation buttons
      const availableWidth = containerWidth - buttonSpace;

      // Calculate how many slides can fit with default width
      const maxSlidesAtDefault = Math.floor(availableWidth / (defaultSlideWidth + margin));
      const totalImages = images.length;

      // Determine slide width based on available space
      let slideWidth;
      if (maxSlidesAtDefault >= Math.min(2, totalImages)) {
        // Use default width if we can show at least 2 images (or all if less than 2)
        slideWidth = Math.min(maxSlideWidth, defaultSlideWidth);
      } else {
        // Calculate width to fit at least 1-2 images, clamped to min/max
        const minVisibleImages = Math.min(2, totalImages);
        const calculatedWidth = (availableWidth - (minVisibleImages * margin)) / minVisibleImages;
        slideWidth = Math.max(minSlideWidth, Math.min(maxSlideWidth, calculatedWidth));
      }

      const visibleCount = Math.max(1, Math.floor(availableWidth / (slideWidth + margin)));

      // Reset current index when game changes
      useEffect(() => {
        setCurrentIndex(0);
      }, [gameId]);

      const carouselData = useMemo(() => ({
        images,
        gameTitle,
        onImageClick: setModalImage
      }), [images, gameTitle]);

      const scrollToPrevious = () => {
        const newIndex = Math.max(0, currentIndex - 1);
        setCurrentIndex(newIndex);
        if (listRef.current) {
          listRef.current.scrollToItem(newIndex, 'start');
        }
      };

      const scrollToNext = () => {
        const maxScrollIndex = Math.max(0, images.length - visibleCount);
        const newIndex = Math.min(maxScrollIndex, currentIndex + 1);
        setCurrentIndex(newIndex);
        if (listRef.current) {
          listRef.current.scrollToItem(newIndex, 'start');
        }
      };

      const canGoPrevious = currentIndex > 0;
      const canGoNext = currentIndex < Math.max(0, images.length - visibleCount);

      // Don't render if no images
      if (!images || images.length === 0) {
        return null;
      }

      return React.createElement('div', {
        className: 'carousel-container',
        ref: containerRef
      }, [
        React.createElement(List, {
          key: `carousel-${gameId}`,
          ref: listRef,
          height: containerHeight,
          width: containerWidth,
          itemCount: images.length,
          itemSize: slideWidth,
          itemData: carouselData,
          layout: 'horizontal',
          overscanCount: 2,
          style: { overflow: 'hidden' }
        }, MemoizedCarouselSlide),

        images.length > visibleCount ? React.createElement('button', {
          key: 'prev-btn',
          className: 'carousel-btn carousel-prev',
          onClick: scrollToPrevious,
          disabled: !canGoPrevious,
          'aria-label': 'Previous image'
        }, '‹') : null,

        images.length > visibleCount ? React.createElement('button', {
          key: 'next-btn',
          className: 'carousel-btn carousel-next',
          onClick: scrollToNext,
          disabled: !canGoNext,
          'aria-label': 'Next image'
        }, '›') : null,

        // Image Modal
        modalImage ? React.createElement('div', {
          key: 'modal',
          className: `image-modal ${modalImage ? 'show' : ''}`,
          onClick: () => setModalImage(null)
        },
          React.createElement('img', {
            src: modalImage,
            alt: `${gameTitle} Expanded View`,
            onClick: () => setModalImage(null)
          })
        ) : null
      ].filter(Boolean));
    }

    function GameRecommendations({ selectedGame, onGameSelect }) {
      const [recommendations, setRecommendations] = useState([]);
      const [isLoading, setIsLoading] = useState(false);

      useEffect(() => {
        if (!selectedGame) {
          setRecommendations([]);
          return;
        }

        setIsLoading(true);
        findSimilarGames(selectedGame, GAMES_DATA, 10)
          .then(results => {
            setRecommendations(results);
            setIsLoading(false);
          })
          .catch(error => {
            console.error('Error getting recommendations:', error);
            setRecommendations([]);
            setIsLoading(false);
          });
      }, [selectedGame]);

      if (!selectedGame) {
        return null;
      }

      if (isLoading) {
        return React.createElement('div', { className: 'recommendations-section' }, [
          React.createElement('div', { className: 'recommendations-title', key: 'title' }, [
            React.createElement('i', { className: 'bi bi-lightbulb', key: 'icon' }),
            'Loading Similar Games...'
          ]),
          React.createElement('div', {
            key: 'loading',
            style: {
              textAlign: 'center',
              padding: '20px',
              color: '#6c757d',
              fontSize: '0.9rem'
            }
          }, 'Analyzing game similarities with MiniLM embeddings...')
        ]);
      }

      if (recommendations.length === 0) {
        return null;
      }

      return React.createElement('div', { className: 'recommendations-section' }, [
        React.createElement('div', { className: 'recommendations-title', key: 'title' }, [
          React.createElement('i', { className: 'bi bi-lightbulb', key: 'icon' }),
          'Similar Games You Might Like'
        ]),
        React.createElement('div', { className: 'recommendations-grid', key: 'grid' },
          recommendations.map(({ game, similarity }) => {
            const similarityPercent = Math.round(similarity * 100);

            return React.createElement('div', {
              className: 'recommendation-item',
              key: game.id,
              onClick: () => onGameSelect(game),
              title: `Click to view ${game.title}`
            }, [
              React.createElement('img', {
                className: 'recommendation-image',
                src: game.square_icon || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23f8f9fa"/><text x="50" y="50" text-anchor="middle" dominant-baseline="middle" fill="%236c757d" font-size="12">No Image</text></svg>',
                alt: game.title,
                key: 'image',
                onError: (e) => {
                  e.target.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect width="100" height="100" fill="%23f8f9fa"/><text x="50" y="50" text-anchor="middle" dominant-baseline="middle" fill="%236c757d" font-size="12">No Image</text></svg>';
                }
              }),
              React.createElement('div', { className: 'recommendation-content', key: 'content' }, [
                React.createElement('div', { className: 'recommendation-title', key: 'title' }, game.title),
                React.createElement('div', { className: 'recommendation-similarity', key: 'similarity' },
                  `${similarityPercent}% similarity similarity`
                ),
                React.createElement('div', { className: 'recommendation-axis', key: 'axis' },
                  React.createElement(AxisVisualization, { axisInfo: game.axis_info })
                )
              ])
            ])
          })
        )
      ]);
    }

    function DetailPanel({ selectedGame, onGameSelect }) {
      if (!selectedGame) {
        return React.createElement('div', { className: 'empty-detail' }, [
          React.createElement('i', { className: 'bi bi-controller', key: 'icon' }),
          React.createElement('h4', { key: 'title' }, 'Select a game'),
          React.createElement('p', { key: 'text' }, 'Click on a game from the list to view details')
        ]);
      }

      const detailStyle = {};
      if (selectedGame.background_image) {
        detailStyle['--bg-image'] = `url(${selectedGame.background_image})`;
      }
      if (selectedGame.vertical_cover) {
        detailStyle['--cover-image'] = `url(${selectedGame.vertical_cover})`;
      }

      return React.createElement('div', {
        className: 'detail-content',
        style: detailStyle
      }, [
        React.createElement('div', { className: 'detail-header', key: 'header' }, [
          React.createElement('button', {
            className: 'back-button',
            onClick: () => onGameSelect(null),
            'aria-label': 'Back to game list'
          }, React.createElement('i', { className: 'bi bi-arrow-left' })),

          // Title Section
          React.createElement('div', { className: 'detail-title', key: 'title' }, selectedGame.title),

          // Platforms Section
          React.createElement('div', { className: 'detail-platform-icons', key: 'icons' },
            selectedGame.platforms.map(platform =>
              React.createElement(PlatformIcon, {
                key: platform,
                platform: platform,
                className: 'detail-platform-icon',
                title: platform.toUpperCase()
              })
            )
          ),
        ]),

        // Two-column layout for meta data and tags
        React.createElement('div', {
          key: 'meta-tags-container',
          className: 'meta-tags-container'
        }, [
          // Left column - Detailed Meta Data
          React.createElement('div', { className: 'detail-meta', key: 'meta' }, [
            React.createElement('div', { className: 'detail-meta-item', key: 'playtime' }, [
              React.createElement('i', { className: 'bi bi-clock meta-icon', key: 'icon' }),
              React.createElement('span', { className: 'meta-label', key: 'label' }, 'Playtime:'),
              React.createElement('span', { className: 'meta-value', key: 'value' }, selectedGame.playtime_display)
            ]),

            React.createElement('div', { className: 'detail-meta-item', key: 'release' }, [
              React.createElement('i', { className: 'bi bi-calendar meta-icon', key: 'icon' }),
              React.createElement('span', { className: 'meta-label', key: 'label' }, 'Released:'),
              React.createElement('span', { className: 'meta-value', key: 'value' }, selectedGame.release_date)
            ]),

            selectedGame.purchase_date !== 'Unknown' ? React.createElement('div', { className: 'detail-meta-item', key: 'purchase' }, [
              React.createElement('i', { className: 'bi bi-cart meta-icon', key: 'icon' }),
              React.createElement('span', { className: 'meta-label', key: 'label' }, 'Purchased:'),
              React.createElement('span', { className: 'meta-value', key: 'value' }, selectedGame.purchase_date)
            ]) : null,

            selectedGame.last_played !== 'Unknown' ? React.createElement('div', { className: 'detail-meta-item', key: 'lastplayed' }, [
              React.createElement('i', { className: 'bi bi-play meta-icon', key: 'icon' }),
              React.createElement('span', { className: 'meta-label', key: 'label' }, 'Last played:'),
              React.createElement('span', { className: 'meta-value', key: 'value' }, selectedGame.last_played)
            ]) : null,

            selectedGame.rating_stars ? React.createElement('div', { className: 'detail-meta-item', key: 'rating' }, [
              React.createElement('i', { className: 'bi bi-star meta-icon', key: 'icon' }),
              React.createElement('span', { className: 'meta-label', key: 'label' }, 'Rating:'),
              React.createElement('span', { className: 'rating-stars', key: 'stars' }, selectedGame.rating_stars)
            ]) : null,

            selectedGame.developers.length > 0 ? React.createElement('div', { className: 'detail-meta-item', key: 'developers' }, [
              React.createElement('i', { className: 'bi bi-people meta-icon', key: 'icon' }),
              React.createElement('span', { className: 'meta-label', key: 'label' }, 'Developer:'),
              React.createElement('span', { className: 'meta-value', key: 'value' }, selectedGame.developers.slice(0, 2).join(', '))
            ]) : null,
          ].filter(Boolean)),

          // Right column - Tags & Genres Section
          (selectedGame.genres.length > 0 || selectedGame.tags.length > 0) ? React.createElement('div', { className: 'detail-tag-genres', key: 'tags-section', style: { flex: 1 } }, [
            React.createElement('div', { className: 'detail-tags', key: 'tags' },
              [...selectedGame.genres, ...selectedGame.tags].map(tag =>
                React.createElement('span', { className: 'detail-tag', key: tag }, tag)
              )
            )
          ]) : null
        ].filter(Boolean)),

        // Media Section
        React.createElement('div', { className: 'detail-media-section', key: 'media' }, [
          // Video Section (Trailer and Gameplay)
          (selectedGame.trailer_id || selectedGame.gameplay_id) ? React.createElement('div', { className: 'video-section', key: 'video-section' }, [
            React.createElement('h6', { key: 'video-title', style: { marginBottom: '7px', color: '#495057', fontSize: '1.1rem', fontWeight: '600' } }, 'Videos'),
            React.createElement('div', { className: 'video-players', key: 'video-players' }, [
              // Trailer
              selectedGame.trailer_id ? React.createElement('div', { className: 'video-player', key: 'trailer-player' }, [
                React.createElement('iframe', {
                  key: 'trailer-iframe',
                  src: `https://www.youtube.com/embed/${selectedGame.trailer_id}?rel=0&modestbranding=1`,
                  title: `${selectedGame.title} Trailer`,
                  allow: 'accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
                  allowFullScreen: true
                })
              ]) : null,

              // Gameplay
              selectedGame.gameplay_id ? React.createElement('div', { className: 'video-player', key: 'gameplay-player' }, [
                React.createElement('iframe', {
                  key: 'gameplay-iframe',
                  src: `https://www.youtube.com/embed/${selectedGame.gameplay_id}?rel=0&modestbranding=1`,
                  title: `${selectedGame.title} Gameplay`,
                  allow: 'accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
                  allowFullScreen: true
                })
              ]) : null
            ].filter(Boolean))
          ]) : null,

          // Image Gallery
          selectedGame.images && selectedGame.images.length > 0 ? React.createElement('div', { className: 'detail-gallery', key: 'gallery' }, [
            React.createElement('h6', { key: 'gallery-title', style: { marginTop: '15px', marginBottom: '0px', color: '#495057', fontSize: '1.1rem', fontWeight: '600' } }, 'Screenshots & Artwork'),
            React.createElement(ImageCarousel, {
              key: `carousel-${selectedGame.id}`,
              images: selectedGame.images,
              gameTitle: selectedGame.title,
              gameId: selectedGame.id
            })
          ]) : null
        ].filter(Boolean)),

        // Detailed Description
        React.createElement('h6', { key: 'description-title', style: { marginBottom: '7px', marginTop: '15px', color: '#495057', fontSize: '1.1rem', fontWeight: '600' } }, 'Detailed Description'),
        selectedGame.description ? React.createElement('div', { className: 'detail-description', key: 'description' }, selectedGame.description) : null,

        // Recommendations Section
        React.createElement(GameRecommendations, {
          key: 'recommendations',
          selectedGame: selectedGame,
          onGameSelect: onGameSelect
        }),

      ].filter(Boolean));
    }

    function ListItem({ index, style, data }) {
      const { games, selectedGame, onGameSelect } = data;
      const game = games[index];
      const isSelected = selectedGame && selectedGame.id === game.id;

      // Apply background image to the list item container
      const itemStyle = {
        ...style,
        '--bg-image': game.square_icon ? `url(${game.square_icon})` : 'none'
      };

      // Add CSS custom property to the game card element
      React.useEffect(() => {
        const cardElement = document.querySelector(`[data-game-id="${game.id}"]`);
        if (cardElement && game.square_icon) {
          cardElement.style.setProperty('--bg-image', `url(${game.square_icon})`);
        }
      }, [game.square_icon, game.id]);

      return React.createElement('div', {
        style: itemStyle,
        'data-game-id': game.id
      },
        React.createElement(GameCard, {
          game,
          isSelected,
          onClick: onGameSelect,
          key: game.id
        })
      );
    }

    // Optimized list item renderer with memoization
    const MemoizedListItem = memo(ListItem);

    // t-SNE implementation using ml-matrix for better performance
    class SimpleTSNE {
      constructor(options = {}) {
        this.perplexity = options.perplexity || 30;
        this.learningRate = options.learningRate || 200;
        this.iterations = options.iterations || 1000;
        this.momentum = 0.8;
        this.finalMomentum = 0.8;
        this.momentumSwitchIter = 250;
        this.stopLyingIter = 100;
        this.lyingCoeff = 4;
        this.epsilon = 1e-12;
      }

      // Compute pairwise squared Euclidean distances using ml-matrix
      computeDistances(X) {
        const matrix = new Matrix(X);
        const n = matrix.rows;
        const distances = new Matrix(n, n);

        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const row1 = matrix.getRow(i);
            const row2 = matrix.getRow(j);
            let dist = 0;
            for (let k = 0; k < row1.length; k++) {
              const diff = row1[k] - row2[k];
              dist += diff * diff;
            }
            distances.set(i, j, dist);
            distances.set(j, i, dist);
          }
        }
        return distances.to2DArray();
      }

      // Compute P matrix (high-dimensional similarities)
      computeP(distances) {
        const n = distances.length;
        const P = new Matrix(n, n);

        // For each point, find perplexity-based sigma
        for (let i = 0; i < n; i++) {
          const beta = this.findBeta(distances[i], i);
          for (let j = 0; j < n; j++) {
            if (i !== j) {
              P.set(i, j, Math.exp(-distances[i][j] * beta));
            }
          }

          // Normalize row
          let rowSum = 0;
          for (let j = 0; j < n; j++) {
            rowSum += P.get(i, j);
          }
          if (rowSum > 0) {
            for (let j = 0; j < n; j++) {
              P.set(i, j, P.get(i, j) / rowSum);
            }
          }
        }

        // Symmetrize
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            const symValue = (P.get(i, j) + P.get(j, i)) / (2 * n);
            P.set(i, j, Math.max(symValue, 1e-12));
          }
        }

        return P.to2DArray();
      }

      // Binary search for beta that gives desired perplexity
      findBeta(distances, excludeIndex) {
        let beta = 1;
        let minBeta = 0;
        let maxBeta = Infinity;
        const targetPerplexity = this.perplexity;

        for (let iter = 0; iter < 50; iter++) {
          let pSum = 0;
          let entropy = 0;

          for (let j = 0; j < distances.length; j++) {
            if (j !== excludeIndex) {
              const p = Math.exp(-distances[j] * beta);
              pSum += p;
              entropy -= p * distances[j] * beta;
            }
          }

          if (pSum === 0) break;

          entropy = entropy / pSum + Math.log(pSum);
          const perplexity = Math.pow(2, entropy);

          if (Math.abs(perplexity - targetPerplexity) < 1e-5) break;

          if (perplexity > targetPerplexity) {
            minBeta = beta;
            beta = maxBeta === Infinity ? beta * 2 : (beta + maxBeta) / 2;
          } else {
            maxBeta = beta;
            beta = (beta + minBeta) / 2;
          }
        }

        return beta;
      }

      // Compute Q matrix (low-dimensional similarities)
      computeQ(Y) {
        const n = Y.length;
        const Q = new Matrix(n, n);
        let sum = 0;

        for (let i = 0; i < n; i++) {
          for (let j = i + 1; j < n; j++) {
            const dx = Y[i][0] - Y[j][0];
            const dy = Y[i][1] - Y[j][1];
            const dist = 1 / (1 + dx * dx + dy * dy);
            Q.set(i, j, dist);
            Q.set(j, i, dist);
            sum += 2 * dist;
          }
        }

        // Normalize
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            Q.set(i, j, Math.max(Q.get(i, j) / sum, 1e-12));
          }
        }

        return Q.to2DArray();
      }

      // Run t-SNE with improved initialization and parameters
      run(X) {
        const n = X.length;

        if (n < 3) {
          console.warn('Too few data points for t-SNE, returning random positions');
          return Array(n).fill().map(() => [Math.random() * 2 - 1, Math.random() * 2 - 1]);
        }

        // Better initialization using PCA-like approach
        const Y = this.initializeY(X);

        // Adjust perplexity based on data size
        this.perplexity = Math.min(this.perplexity, Math.floor((n - 1) / 3));

        // Compute P matrix
        console.log('Computing distance matrix...');
        const distances = this.computeDistances(X);
        console.log('Computing P matrix...');
        const P = this.computeP(distances);

        // Initialize gradients and gains
        const dY = Array(n).fill().map(() => [0, 0]);
        const gains = Array(n).fill().map(() => [1, 1]);

        console.log('Starting t-SNE iterations...');

        for (let iter = 0; iter < this.iterations; iter++) {
          // Compute Q matrix
          const Q = this.computeQ(Y);

          // Compute gradients
          const grads = Array(n).fill().map(() => [0, 0]);

          for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
              if (i !== j) {
                const mult = (P[i][j] - Q[i][j]) * Q[i][j];
                grads[i][0] += mult * (Y[i][0] - Y[j][0]);
                grads[i][1] += mult * (Y[i][1] - Y[j][1]);
              }
            }
          }

          // Apply lying coefficient
          const lying = iter < this.stopLyingIter ? this.lyingCoeff : 1;

          // Update gains and apply gradients
          const momentum = iter < this.momentumSwitchIter ? 0.5 : this.finalMomentum;

          for (let i = 0; i < n; i++) {
            for (let d = 0; d < 2; d++) {
              // Update gains
              const signCheck = Math.sign(grads[i][d]) !== Math.sign(dY[i][d]);
              gains[i][d] = Math.max(
                gains[i][d] * (signCheck ? 1.2 : 0.8),
                0.01
              );

              // Update momentum
              dY[i][d] = momentum * dY[i][d] - this.learningRate * gains[i][d] * grads[i][d] * lying;

              // Update Y
              Y[i][d] += dY[i][d];
            }
          }

          // Center Y
          const meanX = Y.reduce((sum, point) => sum + point[0], 0) / n;
          const meanY = Y.reduce((sum, point) => sum + point[1], 0) / n;
          for (let i = 0; i < n; i++) {
            Y[i][0] -= meanX;
            Y[i][1] -= meanY;
          }

          if (iter % 100 === 0) {
            console.log(`t-SNE iteration ${iter}/${this.iterations}`);
          }
        }

        return Y;
      }

      // Better initialization using variance-based spread
      initializeY(X) {
        const n = X.length;

        if (n === 0) return [];

        // Calculate variance in first few dimensions for scaling
        const numDims = Math.min(10, X[0].length);
        let totalVariance = 0;

        for (let d = 0; d < numDims; d++) {
          const mean = X.reduce((sum, x) => sum + x[d], 0) / n;
          const variance = X.reduce((sum, x) => sum + (x[d] - mean) ** 2, 0) / n;
          totalVariance += variance;
        }

        const scale = Math.sqrt(totalVariance / numDims) * 0.0001;

        return Array(n).fill().map(() => [
          (Math.random() - 0.5) * scale,
          (Math.random() - 0.5) * scale
        ]);
      }
    }

    // Generate t-SNE visualization with better preprocessing
    async function generateClusterVisualization() {
      try {
        console.log('Starting cluster visualization generation...');

        // Get vectors for all games - limit to first 300 for performance
        const gameVectors = [];
        const gameLabels = [];
        const gameGenres = [];
        const gameInfo = [];

        const gamesToProcess = GAMES_DATA; // Limit to first 300 games
        console.log(`Processing first ${gamesToProcess.length} games for clustering...`);

        for (const game of gamesToProcess) {
          const vector = await extractComprehensiveGameVector(game);
          if (vector && vector.length > 0) {
            gameVectors.push(vector);
            gameLabels.push(game.title);
            gameGenres.push(game.genres.length > 0 ? game.genres[0] : 'Unknown');
            gameInfo.push({
              title: game.title,
              genres: game.genres,
              playtime: game.playtime_minutes || 0,
              isPlayed: game.is_played || false
            });
          }
        }

        if (gameVectors.length < 3) {
          throw new Error('Not enough valid game vectors for clustering');
        }

        console.log(`Actually processing ${gameVectors.length} games for clustering...`);

        // Standardize the vectors (z-score normalization)
        const standardizedVectors = standardizeVectors(gameVectors);

        // Adjust parameters based on data size
        const perplexity = 50; //Math.min(30, Math.max(5, Math.floor(gameVectors.length / 4)));
        const numClusters = 32; //Math.min(8, Math.max(2, Math.floor(gameVectors.length / 15)));

        console.log(`Using perplexity: ${perplexity}, clusters: ${numClusters}`);

        // Run t-SNE on standardized data
        const tsne = new SimpleTSNE({
          perplexity: perplexity,
          iterations: 1000,
          learningRate: 200, /*Math.max(100, gameVectors.length * 2)*/
        });

        const tsneResult = tsne.run(standardizedVectors);

        // Run K-means clustering on standardized vectors
        const kmeans = new KMeans(standardizedVectors, numClusters, {
          initialization: 'kmeans++',
          maxIterations: 300,
          tolerance: 1e-6
        });

        const clusterResult = kmeans.clusters;

        // Analyze clusters for meaningful groupings
        const clusterAnalysis = analyzeClusterMeanings(gameInfo, clusterResult, numClusters);

        console.log(`Generated ${numClusters} clusters:`, clusterAnalysis);

        // Prepare data for plotting with better hover info
        const x = tsneResult.map(point => point[0]);
        const y = tsneResult.map(point => point[1]);
        const colors = clusterResult;
        const text = gameLabels.map((label, i) => {
          const info = gameInfo[i];
          const cluster = clusterAnalysis[colors[i]];
          return `${label}<br>` +
            `Genre: ${gameGenres[i]}<br>` +
            `Playtime: ${Math.round(info.playtime / 60)}h<br>` +
            `Cluster: ${cluster.name}<br>` +
            `Played: ${info.isPlayed ? 'Yes' : 'No'}`;
        });

        // Create color palette with better contrast
        const colorPalette = [
          '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
          '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400'
        ];

        const trace = {
          x: x,
          y: y,
          mode: 'markers',
          type: 'scatter',
          text: text,
          hovertemplate: '%{text}<extra></extra>',
          marker: {
            size: 10,
            color: colors,
            colorscale: colorPalette.slice(0, numClusters).map((color, i) => [i / Math.max(1, numClusters - 1), color]),
            showscale: true,
            line: {
              width: 1,
              color: 'white'
            },
            colorbar: {
              title: 'Cluster',
              titleside: 'right',
              tickmode: 'array',
              tickvals: Array.from({ length: numClusters }, (_, i) => i),
              ticktext: Array.from({ length: numClusters }, (_, i) => clusterAnalysis[i].name)
            }
          }
        };

        const layout = {
          title: {
            text: `Game Library Clusters (t-SNE + K-Means)<br><sub>First ${gamesToProcess.length} games - Perplexity: ${perplexity}, Clusters: ${numClusters}</sub>`,
            font: { size: 16 }
          },
          xaxis: {
            title: 't-SNE Dimension 1',
            showgrid: true,
            zeroline: false
          },
          yaxis: {
            title: 't-SNE Dimension 2',
            showgrid: true,
            zeroline: false
          },
          hovermode: 'closest',
          plot_bgcolor: '#f8f9fa',
          paper_bgcolor: 'white',
          margin: { t: 80, r: 120, b: 60, l: 60 }
        };

        const config = {
          responsive: true,
          displayModeBar: true,
          modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'autoScale2d'],
          displaylogo: false
        };

        return { trace, layout, config, clusterAnalysis };

      } catch (error) {
        console.error('Error generating cluster visualization:', error);
        throw error;
      }
    }

    // Standardize vectors for better clustering
    function standardizeVectors(vectors) {
      if (vectors.length === 0) return vectors;

      const numFeatures = vectors[0].length;
      const means = new Array(numFeatures).fill(0);
      const stds = new Array(numFeatures).fill(0);

      // Calculate means
      for (let i = 0; i < vectors.length; i++) {
        for (let j = 0; j < numFeatures; j++) {
          means[j] += vectors[i][j];
        }
      }
      for (let j = 0; j < numFeatures; j++) {
        means[j] /= vectors.length;
      }

      // Calculate standard deviations
      for (let i = 0; i < vectors.length; i++) {
        for (let j = 0; j < numFeatures; j++) {
          stds[j] += (vectors[i][j] - means[j]) ** 2;
        }
      }
      for (let j = 0; j < numFeatures; j++) {
        stds[j] = Math.sqrt(stds[j] / vectors.length);
        if (stds[j] === 0) stds[j] = 1; // Avoid division by zero
      }

      // Standardize
      return vectors.map(vector =>
        vector.map((val, j) => (val - means[j]) / stds[j])
      );
    }

    // Analyze what each cluster represents
    function analyzeClusterMeanings(gameInfo, clusterResult, numClusters) {
      const clusters = Array(numClusters).fill().map(() => ({
        games: [],
        genres: {},
        avgPlaytime: 0,
        playedRatio: 0
      }));

      // Group games by cluster
      gameInfo.forEach((game, i) => {
        const clusterId = clusterResult[i];
        clusters[clusterId].games.push(game);

        // Count genres
        game.genres.forEach(genre => {
          clusters[clusterId].genres[genre] = (clusters[clusterId].genres[genre] || 0) + 1;
        });
      });

      // Analyze each cluster
      return clusters.map((cluster, i) => {
        if (cluster.games.length === 0) {
          return { name: `Cluster ${i + 1}`, description: 'Empty cluster' };
        }

        // Most common genre
        const topGenre = Object.entries(cluster.genres)
          .sort(([, a], [, b]) => b - a)[0];

        // Average playtime
        const avgPlaytime = cluster.games.reduce((sum, game) => sum + game.playtime, 0) / cluster.games.length;

        // Played ratio
        const playedCount = cluster.games.filter(game => game.isPlayed).length;
        const playedRatio = playedCount / cluster.games.length;

        // Generate cluster name
        let name = `Cluster ${i + 1}`;
        if (topGenre && topGenre[1] > 1) {
          name = `${topGenre[0]} Games`;
        }

        if (avgPlaytime > 600) { // 10+ hours
          name += ' (High Playtime)';
        } else if (avgPlaytime < 60) { // <1 hour
          name += ' (Low Playtime)';
        }

        if (playedRatio > 0.8) {
          name += ' - Played';
        } else if (playedRatio < 0.2) {
          name += ' - Unplayed';
        }

        return {
          name: name,
          topGenre: topGenre ? topGenre[0] : 'Mixed',
          avgPlaytime: Math.round(avgPlaytime / 60),
          playedRatio: Math.round(playedRatio * 100),
          gameCount: cluster.games.length
        };
      });
    }

    // Cluster visualization modal component
    function ClusterModal({ isOpen, onClose }) {
      const [isLoading, setIsLoading] = useState(true);
      const [plotData, setPlotData] = useState(null);
      const [error, setError] = useState(null);
      const plotRef = useRef(null);

      useEffect(() => {
        if (isOpen && !plotData) {
          setIsLoading(true);
          setError(null);

          generateClusterVisualization()
            .then(data => {
              setPlotData(data);
              setIsLoading(false);
            })
            .catch(err => {
              console.error('Cluster visualization error:', err);
              setError(err.message);
              setIsLoading(false);
            });
        }
      }, [isOpen, plotData]);

      useEffect(() => {
        if (plotData && plotRef.current && !isLoading) {
          Plotly.newPlot(plotRef.current, [plotData.trace], plotData.layout, plotData.config);
        }
      }, [plotData, isLoading]);

      if (!isOpen) return null;

      return React.createElement('div', {
        className: `cluster-modal ${isOpen ? 'show' : ''}`,
        onClick: onClose
      },
        React.createElement('div', {
          className: 'cluster-modal-content',
          onClick: (e) => e.stopPropagation()
        }, [
          React.createElement('div', { className: 'cluster-modal-header', key: 'header' }, [
            React.createElement('h3', { className: 'cluster-modal-title', key: 'title' },
              'Game Library Cluster Analysis'
            ),
            React.createElement('button', {
              className: 'cluster-close-btn',
              onClick: onClose,
              key: 'close'
            }, '×')
          ]),
          React.createElement('div', { className: 'cluster-plot-container', key: 'content' }, [
            isLoading ? React.createElement('div', { className: 'cluster-loading', key: 'loading' }, [
              React.createElement('i', { className: 'bi bi-arrow-repeat', key: 'icon' }),
              React.createElement('div', { key: 'text' }, [
                React.createElement('h4', { key: 'title' }, 'Generating Cluster Visualization'),
                React.createElement('p', { key: 'desc' }, 'Computing t-SNE embeddings and K-means clusters...')
              ])
            ]) : null,
            error ? React.createElement('div', {
              key: 'error',
              style: {
                textAlign: 'center',
                padding: '40px',
                color: '#dc3545'
              }
            }, [
              React.createElement('h4', { key: 'title' }, 'Error generating visualization'),
              React.createElement('p', { key: 'msg' }, error)
            ]) : null,
            !isLoading && !error ? React.createElement('div', {
              ref: plotRef,
              key: 'plot',
              style: { width: '100%', height: '100%' }
            }) : null
          ])
        ])
      );
    }

    function GameLibrary() {
      const [searchTerm, setSearchTerm] = useState('');
      const [activeFilter, setActiveFilter] = useState('all');
      const [selectedGame, setSelectedGame] = useState(null);
      const [containerHeight, setContainerHeight] = useState(600);
      const [showClusterModal, setShowClusterModal] = useState(false);

      // URL-based navigation and history management
      const handleGameSelect = (game) => {
        if (game && game.id) {
          // Update URL without page reload
          window.history.pushState({ gameId: game.id }, '', `#game-${game.id}`);
          setSelectedGame(game);
        } else {
          // Clear selection
          window.history.pushState({}, '', window.location.pathname);
          setSelectedGame(null);
        }
      };

      // Function to find and set game from URL hash
      const setGameFromHash = (hash) => {
        if (hash.startsWith('#game-')) {
          const gameId = hash.replace('#game-', '');
          const game = GAMES_DATA.find(g => g.id === gameId);
          if (game) {
            setSelectedGame(game);
            return true;
          } else {
            // Game not found, clear URL
            window.history.replaceState({}, '', window.location.pathname);
            setSelectedGame(null);
            return false;
          }
        } else {
          setSelectedGame(null);
          return true;
        }
      };

      // Handle browser back/forward navigation
      useEffect(() => {
        const handlePopState = (event) => {
          const hash = window.location.hash;
          setGameFromHash(hash);
        };

        // Handle initial page load with hash
        const initialHash = window.location.hash;
        if (initialHash) {
          setGameFromHash(initialHash);
        }

        // Listen for browser navigation events
        window.addEventListener('popstate', handlePopState);

        return () => {
          window.removeEventListener('popstate', handlePopState);
        };
      }, []); // Empty dependency array to run only once

      // Calculate optimal container height based on viewport
      useEffect(() => {
        const updateHeight = () => {
          const viewportHeight = window.innerHeight;
          const calculatedHeight = Math.max(300, viewportHeight - 200);
          setContainerHeight(calculatedHeight);
        };

        updateHeight();
        window.addEventListener('resize', updateHeight);
        return () => window.removeEventListener('resize', updateHeight);
      }, []);

      // Expose game selection function for recommendations
      useEffect(() => {
        window.selectGameFromRecommendation = handleGameSelect;
        return () => {
          delete window.selectGameFromRecommendation;
        };
      }, []);

      // Updated item height for taller cards with axis visualization
      const itemHeight = 105;
      const visibleItemCount = Math.ceil(containerHeight / itemHeight);
      const bufferSize = Math.min(3, Math.ceil(visibleItemCount * 0.5));

      const filteredGames = useMemo(() => {
        return GAMES_DATA.filter(game => {
          // Search filter
          const searchLower = searchTerm.toLowerCase();
          const matchesSearch = !searchTerm ||
            game.title.toLowerCase().includes(searchLower) ||
            game.description.toLowerCase().includes(searchLower) ||
            game.genres.some(g => g.toLowerCase().includes(searchLower)) ||
            game.tags.some(t => t.toLowerCase().includes(searchLower));

          // Category filter
          let matchesFilter = true;
          switch (activeFilter) {
            case 'played':
              matchesFilter = game.is_played;
              break;
            case 'unplayed':
              matchesFilter = !game.is_played;
              break;
            case 'recent':
              matchesFilter = game.is_recent;
              break;
            case 'all':
            default:
              matchesFilter = true;
              break;
          }

          return matchesSearch && matchesFilter;
        });
      }, [searchTerm, activeFilter]);

      const listData = useMemo(() => ({
        games: filteredGames,
        selectedGame,
        onGameSelect: handleGameSelect
      }), [filteredGames, selectedGame]);

      // Add CSS for dynamic background images
      const style = document.createElement('style');
      style.textContent = `
        .game-card::before {
          background-image: var(--bg-image, none);
        }
        .detail-content::before {
          background-image: var(--bg-image, none);
        }
        .detail-content::after {
          background-image: var(--cover-image, none);
        }
      `;
      document.head.appendChild(style);

      return React.createElement('div', { className: 'main-container' }, [
        // Header
        React.createElement('div', { className: 'header', key: 'header' }, [
          React.createElement('h1', { key: 'title' }, [
            React.createElement('i', { className: 'bi bi-joystick', key: 'icon' }),
            ' GOG Galaxy Game Library',
            React.createElement('button', {
              className: 'cluster-viz-btn',
              onClick: () => setShowClusterModal(true),
              key: 'cluster-btn',
              title: 'View cluster analysis of your game library'
            }, [
              React.createElement('i', { className: 'bi bi-diagram-3', key: 'cluster-icon' }),
              'Cluster Analysis'
            ])
          ]),
          React.createElement('div', { className: 'stats-row', key: 'stats' }, [
            React.createElement('div', { className: 'stat-item', key: 'total' }, [
              React.createElement('span', { className: 'stat-number', key: 'num' }, '[[total_games]]'),
              React.createElement('span', { className: 'stat-label', key: 'label' }, 'Total Games')
            ]),
            React.createElement('div', { className: 'stat-item', key: 'played' }, [
              React.createElement('span', { className: 'stat-number', key: 'num' }, '[[played_games]]'),
              React.createElement('span', { className: 'stat-label', key: 'label' }, 'Games Played')
            ]),
            React.createElement('div', { className: 'stat-item', key: 'hours' }, [
              React.createElement('span', { className: 'stat-number', key: 'num' }, '[[total_hours]]h'),
              React.createElement('span', { className: 'stat-label', key: 'label' }, 'Hours Played')
            ]),
            React.createElement('div', { className: 'stat-item', key: 'platforms' }, [
              React.createElement('span', { className: 'stat-number', key: 'num' }, '[[platform_count]]'),
              React.createElement('span', { className: 'stat-label', key: 'label' }, 'Platforms')
            ])
          ])
        ]),

        // Controls
        React.createElement('div', { className: 'controls', key: 'controls' }, [
          React.createElement('div', { className: 'row g-3', key: 'row' }, [
            React.createElement('div', { className: 'search-col', key: 'search-col' }, [
              React.createElement('div', { className: 'search-box', key: 'search' }, [
                React.createElement('input', {
                  key: 'input',
                  type: 'text',
                  className: 'form-control',
                  placeholder: 'Search games...',
                  value: searchTerm,
                  onChange: (e) => setSearchTerm(e.target.value)
                }),
                React.createElement('i', { className: 'bi bi-search', key: 'icon' })
              ])
            ]),
            React.createElement('div', { className: 'col-md-6', key: 'filter-col' }, [
              React.createElement('div', { className: 'filter-buttons', key: 'filters' }, [
                ['all', 'All Games'],
                ['played', 'Played'],
                ['unplayed', 'Unplayed'],
                ['recent', 'Recent']
              ].map(([filter, label]) =>
                React.createElement('button', {
                  key: filter,
                  className: `filter-btn ${activeFilter === filter ? 'active' : ''}`,
                  onClick: () => setActiveFilter(filter)
                }, label)
              ))
            ])
          ])
        ]),

        // Main Content

        React.createElement('div', { className: 'main-content', key: 'main' }, [
          // Games List Panel
          React.createElement('div', { className: 'games-list-panel', key: 'list-panel' }, [
            filteredGames.length > 0 ? React.createElement('div', { className: 'games-grid', key: 'grid' },
              React.createElement(List, {
                height: containerHeight,
                itemCount: filteredGames.length,
                itemSize: itemHeight,
                itemData: listData,
                overscanCount: bufferSize
              }, MemoizedListItem)
            ) : React.createElement('div', { className: 'no-results', key: 'no-results' }, [
              React.createElement('i', { className: 'bi bi-search', key: 'icon' }),
              React.createElement('h4', { key: 'title' }, 'No games found'),
              React.createElement('p', { key: 'text' }, 'Try adjusting your search or filter criteria.')
            ]),
          ]),

          // Detail Panel
          React.createElement('div', { className: 'detail-panel', key: 'detail-panel' },
            React.createElement(DetailPanel, {
              selectedGame,
              onGameSelect: handleGameSelect,
              key: 'detail'
            })
          )
        ]),

        // Cluster Modal
        React.createElement(ClusterModal, {
          key: 'cluster-modal',
          isOpen: showClusterModal,
          onClose: () => setShowClusterModal(false)
        })
      ]);
    }

    // Render the app
    const root = createRoot(document.getElementById('root'));
    root.render(React.createElement(GameLibrary));

    // Add carousel functionality to window object
    window.moveCarousel = function (carouselId, direction) {
      const track = document.getElementById(carouselId);
      if (!track) return;

      const slides = track.children;
      const slideWidth = slides[0].offsetWidth + 10; // Include margin
      const currentTransform = track.style.transform || 'translateX(0px)';
      const currentX = parseInt(currentTransform.match(/-?\d+/) || [0])[0];

      let newX = currentX + (direction * slideWidth * -1);
      const maxX = -(slideWidth * (slides.length - 3)); // Show 3 images at once

      if (newX > 0) newX = 0;
      if (newX < maxX) newX = maxX;

      track.style.transform = `translateX(${newX}px)`;
    };
  </script>
</body>

</html>